<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ Self-Made AI Agent</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: #e0e6ed;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.5rem;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.3rem 0.8rem;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 20px;
            font-size: 0.8rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: #00ff00;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem 0;
            scroll-behavior: smooth;
        }

        .message {
            margin-bottom: 1.5rem;
            display: flex;
            gap: 0.8rem;
            align-items: flex-start;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .message.user .message-avatar {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .message.ai .message-avatar {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .message-content {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.8rem 1.2rem;
            border-radius: 18px;
            max-width: 70%;
            line-height: 1.5;
            position: relative;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, #667eea, #764ba2);
            margin-left: auto;
        }

        .message.ai .message-content {
            background: rgba(255, 255, 255, 0.1);
        }

        .message-time {
            font-size: 0.7rem;
            color: #8892b0;
            margin-top: 0.3rem;
        }

        .metadata {
            display: block;
            margin-top: 0.3rem;
            font-size: 0.65rem;
            color: #64ffda;
            opacity: 0.7;
        }

        .typing-indicator .message-content {
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .typing-dots {
            display: flex;
            gap: 2px;
        }

        .typing-dots span {
            width: 4px;
            height: 4px;
            background: #64ffda;
            border-radius: 50%;
            animation: typing 1.4s ease-in-out infinite;
        }

        .typing-dots span:nth-child(1) { animation-delay: 0s; }
        .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
        .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0%, 60%, 100% { transform: translateY(0); opacity: 0.3; }
            30% { transform: translateY(-10px); opacity: 1; }
        }

        .input-container {
            padding: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .input-wrapper {
            display: flex;
            gap: 0.5rem;
            align-items: flex-end;
            max-width: 800px;
            margin: 0 auto;
        }

        .message-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 0.8rem 1.2rem;
            color: #e0e6ed;
            font-size: 0.95rem;
            resize: none;
            min-height: 44px;
            max-height: 120px;
            font-family: inherit;
            outline: none;
            transition: all 0.3s ease;
        }

        .message-input:focus {
            border-color: #64ffda;
            box-shadow: 0 0 0 2px rgba(100, 255, 218, 0.2);
        }

        .message-input::placeholder {
            color: #8892b0;
        }

        .send-button {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #64ffda, #00bcd4);
            border: none;
            border-radius: 50%;
            color: #0a192f;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .send-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(100, 255, 218, 0.4);
        }

        .send-button:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: #8892b0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .sidebar {
            width: 300px;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem;
            overflow-y: auto;
        }

        .sidebar h3 {
            color: #64ffda;
            margin-bottom: 1rem;
            font-size: 1rem;
        }

        .stats-grid {
            display: grid;
            gap: 0.8rem;
            margin-bottom: 1.5rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.8rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 0.7rem;
            color: #8892b0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #e0e6ed;
            margin-top: 0.2rem;
        }

        .controls {
            display: grid;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .control-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e6ed;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .control-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #64ffda;
        }

        .toggle-sidebar {
            display: none;
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e0e6ed;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            z-index: 1000;
        }

        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                right: 0;
                height: 100vh;
                transform: translateX(100%);
                transition: transform 0.3s ease;
                z-index: 999;
            }
            
            .sidebar.open {
                transform: translateX(0);
            }
            
            .toggle-sidebar {
                display: block;
            }
        }

        .welcome-message {
            text-align: center;
            padding: 2rem;
            color: #8892b0;
            font-style: italic;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ü§ñ Self-Made AI Agent</h1>
        <div class="status">
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span id="status-text">Online</span>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div class="chat-container" id="chat-container">
            <div class="messages" id="messages">
                <div class="welcome-message">
                    üß† AI Agent ƒëang kh·ªüi t·∫°o... Vui l√≤ng ch·ªù m·ªôt ch√∫t.
                </div>
            </div>

            <div class="input-container">
                <div class="input-wrapper">
                    <textarea 
                        id="message-input" 
                        class="message-input" 
                        placeholder="Nh·∫≠p tin nh·∫Øn c·ªßa b·∫°n..."
                        rows="1"
                    ></textarea>
                    <button id="send-button" class="send-button" disabled>
                        ‚û§
                    </button>
                </div>
            </div>
        </div>

        <div class="sidebar" id="sidebar">
            <h3>üìä Statistics</h3>
            <div class="stats-grid" id="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Conversations</div>
                    <div class="stat-value" id="stat-conversations">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Response Time</div>
                    <div class="stat-value" id="stat-response-time">0ms</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Memory Usage</div>
                    <div class="stat-value" id="stat-memory">0%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Vocabulary</div>
                    <div class="stat-value" id="stat-vocabulary">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Learning</div>
                    <div class="stat-value" id="stat-learning">ON</div>
                </div>
            </div>

            <h3>üéõÔ∏è Controls</h3>
            <div class="controls">
                <button class="control-button" onclick="toggleLearning()">Toggle Learning</button>
                <button class="control-button" onclick="trainAI()">Train Neural Net</button>
                <button class="control-button" onclick="saveAgent()">Save Agent</button>
                <button class="control-button" onclick="loadAgent()">Load Agent</button>
                <button class="control-button" onclick="exportChat()">Export Chat</button>
                <button class="control-button" onclick="resetAgent()">Reset Agent</button>
            </div>

            <h3>üß† Recent Insights</h3>
            <div id="insights" class="stat-card" style="margin-top: 0.5rem;">
                <div style="font-size: 0.8rem; color: #8892b0;">
                    AI is learning from conversations...
                </div>
            </div>
        </div>
    </div>

    <button class="toggle-sidebar" id="toggle-sidebar" onclick="toggleSidebar()">
        üìä
    </button>

    <!-- Load AI Components -->
    <script>
        // Matrix and Neural Network Implementation
        class Matrix {
            constructor(rows, cols, data = null) {
                this.rows = rows;
                this.cols = cols;
                this.data = data || Array(rows).fill().map(() => Array(cols).fill(0));
            }

            static random(rows, cols) {
                const matrix = new Matrix(rows, cols);
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        matrix.data[i][j] = Math.random() * 2 - 1;
                    }
                }
                return matrix;
            }

            multiply(other) {
                if (this.cols !== other.rows) {
                    throw new Error('Matrix dimensions incompatible');
                }
                
                const result = new Matrix(this.rows, other.cols);
                for (let i = 0; i < result.rows; i++) {
                    for (let j = 0; j < result.cols; j++) {
                        let sum = 0;
                        for (let k = 0; k < this.cols; k++) {
                            sum += this.data[i][k] * other.data[k][j];
                        }
                        result.data[i][j] = sum;
                    }
                }
                return result;
            }

            add(other) {
                const result = new Matrix(this.rows, this.cols);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        result.data[i][j] = this.data[i][j] + other.data[i][j];
                    }
                }
                return result;
            }

            map(func) {
                const result = new Matrix(this.rows, this.cols);
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        result.data[i][j] = func(this.data[i][j]);
                    }
                }
                return result;
            }
        }

        // Simple Neural Network
        class SimpleNeuralNetwork {
            constructor() {
                this.weights1 = Matrix.random(10, 8);
                this.weights2 = Matrix.random(8, 5);
                this.bias1 = Matrix.random(1, 8);
                this.bias2 = Matrix.random(1, 5);
            }

            sigmoid(x) {
                return 1 / (1 + Math.exp(-x));
            }

            forward(input) {
                const inputMatrix = new Matrix(1, input.length, [input]);
                const hidden = inputMatrix.multiply(this.weights1).add(this.bias1).map(this.sigmoid);
                const output = hidden.multiply(this.weights2).add(this.bias2).map(this.sigmoid);
                return output.data[0];
            }
        }

        // Simple NLP Processor
        class SimpleNLP {
            constructor() {
                this.vocabulary = new Map();
                this.stopWords = new Set(['l√†', 'c·ªßa', 'v√†', 'c√≥', 'trong', 'm·ªôt', 'v·ªõi', 'ƒë∆∞·ª£c', 'ƒë·ªÉ', 'c√°c']);
                this.sentimentWords = {
                    positive: ['t·ªët', 'hay', 'ƒë·∫πp', 'y√™u', 'th√≠ch', 'vui', 'tuy·ªát'],
                    negative: ['x·∫•u', 't·ªá', 'gh√©t', 'bu·ªìn', 't·ª©c', 'd·ªü']
                };
            }

            tokenize(text) {
                return text.toLowerCase()
                    .replace(/[^\w\s√°√†·∫£√£·∫°ƒÉ·∫Ø·∫±·∫≥·∫µ·∫∑√¢·∫•·∫ß·∫©·∫´·∫≠ƒë√©√®·∫ª·∫Ω·∫π√™·∫ø·ªÅ·ªÉ·ªÖ·ªá√≠√¨·ªâƒ©·ªã√≥√≤·ªè√µ·ªç√¥·ªë·ªì·ªï·ªó·ªô∆°·ªõ·ªù·ªü·ª°·ª£√∫√π·ªß≈©·ª•∆∞·ª©·ª´·ª≠·ªØ·ª±√Ω·ª≥·ª∑·ªπ·ªµ]/g, ' ')
                    .split(/\s+/)
                    .filter(token => token.length > 0);
            }

            analyzeSentiment(text) {
                const tokens = this.tokenize(text);
                let score = 0;
                
                tokens.forEach(token => {
                    if (this.sentimentWords.positive.includes(token)) score += 1;
                    if (this.sentimentWords.negative.includes(token)) score -= 1;
                });

                return {
                    sentiment: score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral',
                    score: score
                };
            }

            classifyIntent(text) {
                const lowerText = text.toLowerCase();
                
                if (/^(xin ch√†o|ch√†o|hello|hi)/.test(lowerText)) return 'greeting';
                if (/\?|g√¨|ai|ƒë√¢u|khi n√†o|t·∫°i sao/.test(lowerText)) return 'question';
                if (/t·∫°m bi·ªát|bye|goodbye/.test(lowerText)) return 'goodbye';
                if (/c·∫£m ∆°n|thanks/.test(lowerText)) return 'thanks';
                if (/\d+\s*[\+\-\*\/]\s*\d+/.test(lowerText)) return 'math';
                
                return 'general';
            }

            textToVector(text, size = 10) {
                const tokens = this.tokenize(text);
                const vector = new Array(size).fill(0);
                
                tokens.forEach((token, index) => {
                    if (index < size && !this.stopWords.has(token)) {
                        vector[index] = token.charCodeAt(0) % 100 / 100;
                    }
                });
                
                return vector;
            }
        }

        // Simple Memory System
        class SimpleMemory {
            constructor() {
                this.shortTerm = [];
                this.longTerm = [];
                this.maxShortTerm = 10;
                this.maxLongTerm = 100;
            }

            addShortTerm(item) {
                this.shortTerm.push({
                    content: item,
                    timestamp: Date.now(),
                    importance: Math.random()
                });

                if (this.shortTerm.length > this.maxShortTerm) {
                    const removed = this.shortTerm.shift();
                    if (removed.importance > 0.7) {
                        this.addLongTerm(removed.content);
                    }
                }
            }

            addLongTerm(item) {
                this.longTerm.push({
                    content: item,
                    timestamp: Date.now(),
                    accessCount: 0
                });

                if (this.longTerm.length > this.maxLongTerm) {
                    this.longTerm.shift();
                }
            }

            recall(query) {
                const allMemories = [...this.shortTerm, ...this.longTerm];
                return allMemories
                    .filter(memory => 
                        memory.content.toLowerCase().includes(query.toLowerCase()) ||
                        query.toLowerCase().includes(memory.content.toLowerCase())
                    )
                    .sort((a, b) => b.timestamp - a.timestamp);
            }

            getStats() {
                return {
                    shortTerm: this.shortTerm.length,
                    longTerm: this.longTerm.length,
                    usage: Math.round((this.shortTerm.length / this.maxShortTerm) * 100)
                };
            }
        }

        // Main AI Agent
        class AIAgent {
            constructor() {
                this.name = 'AI Assistant';
                this.brain = new SimpleNeuralNetwork();
                this.nlp = new SimpleNLP();
                this.memory = new SimpleMemory();
                this.conversationHistory = [];
                this.isLearning = true;
                this.responseLatency = [];
                
                this.loadKnowledge();
            }

            loadKnowledge() {
                const knowledge = [
                    'T√¥i l√† AI assistant th√¥ng minh',
                    'T√¥i c√≥ th·ªÉ h·ªçc t·ª´ cu·ªôc tr√≤ chuy·ªán', 
                    'JavaScript l√† ng√¥n ng·ªØ l·∫≠p tr√¨nh',
                    'AI l√† tr√≠ tu·ªá nh√¢n t·∫°o',
                    'Machine learning gi√∫p AI h·ªçc h·ªèi'
                ];

                knowledge.forEach(item => this.memory.addLongTerm(item));
            }

            async processMessage(message) {
                const startTime = Date.now();
                
                try {
                    // Ph√¢n t√≠ch input
                    const sentiment = this.nlp.analyzeSentiment(message);
                    const intent = this.nlp.classifyIntent(message);
                    
                    // Th√™m v√†o memory
                    this.memory.addShortTerm(message);
                    
                    // T·∫°o response
                    const response = this.generateResponse(message, intent, sentiment);
                    
                    // L∆∞u conversation
                    this.conversationHistory.push({
                        user: message,
                        ai: response.content,
                        timestamp: Date.now(),
                        intent,
                        sentiment
                    });

                    const processingTime = Date.now() - startTime;
                    this.responseLatency.push(processingTime);

                    return {
                        content: response.content,
                        confidence: response.confidence,
                        intent,
                        sentiment,
                        processingTime
                    };

                } catch (error) {
                    console.error('AI Processing Error:', error);
                    return {
                        content: 'Xin l·ªói, t√¥i g·∫∑p s·ª± c·ªë. H√£y th·ª≠ l·∫°i nh√©!',
                        confidence: 0.5,
                        error: true,
                        processingTime: Date.now() - startTime
                    };
                }
            }

            generateResponse(message, intent, sentiment) {
                let response = '';
                let confidence = 0.5;

                // Intent-based responses
                switch (intent) {
                    case 'greeting':
                        const greetings = [
                            'Xin ch√†o! T√¥i l√† AI assistant. T√¥i c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n?',
                            'Ch√†o b·∫°n! R·∫•t vui ƒë∆∞·ª£c tr√≤ chuy·ªán v·ªõi b·∫°n!',
                            'Hi! T√¥i s·∫µn s√†ng h·ªó tr·ª£ b·∫°n.'
                        ];
                        response = greetings[Math.floor(Math.random() * greetings.length)];
                        confidence = 0.9;
                        break;

                    case 'question':
                        const memories = this.memory.recall(message);
                        if (memories.length > 0) {
                            response = `V·ªÅ v·∫•n ƒë·ªÅ n√†y, ${memories[0].content}`;
                            confidence = 0.7;
                        } else {
                            response = 'ƒê√≥ l√† c√¢u h·ªèi hay! T√¥i ƒëang suy nghƒ© v·ªÅ ƒëi·ªÅu n√†y...';
                            confidence = 0.6;
                        }
                        break;

                    case 'goodbye':
                        response = 'T·∫°m bi·ªát! R·∫•t vui ƒë∆∞·ª£c tr√≤ chuy·ªán v·ªõi b·∫°n!';
                        confidence = 0.9;
                        break;

                    case 'thanks':
                        response = 'Kh√¥ng c√≥ g√¨! T√¥i r·∫•t vui ƒë∆∞·ª£c gi√∫p b·∫°n.';
                        confidence = 0.9;
                        break;

                    case 'math':
                        const mathMatch = message.match(/(\d+)\s*([+\-*/])\s*(\d+)/);
                        if (mathMatch) {
                            try {
                                const result = eval(mathMatch[0]);
                                response = `K·∫øt qu·∫£ l√†: ${result}`;
                                confidence = 0.95;
                            } catch (e) {
                                response = 'T√¥i kh√¥ng th·ªÉ t√≠nh ƒë∆∞·ª£c ph√©p to√°n n√†y.';
                                confidence = 0.3;
                            }
                        }
                        break;

                    default:
                        // Pattern matching
                        if (message.toLowerCase().includes('t√™n')) {
                            response = `T√¥i l√† ${this.name}, m·ªôt AI assistant th√¥ng minh!`;
                            confidence = 0.8;
                        } else if (message.toLowerCase().includes('th·ªùi gian')) {
                            response = `Hi·ªán t·∫°i l√†: ${new Date().toLocaleString('vi-VN')}`;
                            confidence = 0.9;
                        } else {
                            // Fallback responses
                            const fallbacks = [
                                'ƒê√≥ l√† ƒëi·ªÅu th√∫ v·ªã! B·∫°n c√≥ th·ªÉ chia s·∫ª th√™m kh√¥ng?',
                                'T√¥i ƒëang h·ªçc v·ªÅ ch·ªß ƒë·ªÅ n√†y. H√£y d·∫°y t√¥i th√™m!',
                                'Hmm, ƒë·ªÉ t√¥i suy nghƒ© v·ªÅ ƒëi·ªÅu n√†y...',
                                'T√¥i hi·ªÉu √Ω b·∫°n. C√≥ th·ªÉ b·∫°n gi·∫£i th√≠ch r√µ h∆°n?'
                            ];
                            response = fallbacks[Math.floor(Math.random() * fallbacks.length)];
                            confidence = 0.4;
                        }
                }

                // Sentiment adjustment
                if (sentiment.sentiment === 'positive') {
                    response += ' üòä';
                } else if (sentiment.sentiment === 'negative') {
                    response = 'T√¥i th·∫•y b·∫°n c√≥ v·∫ª kh√¥ng vui. ' + response;
                }

                return { content: response, confidence };
            }

            getStats() {
                const memoryStats = this.memory.getStats();
                return {
                    conversations: this.conversationHistory.length,
                    averageResponseTime: this.responseLatency.length > 0 ? 
                        Math.round(this.responseLatency.reduce((a, b) => a + b, 0) / this.responseLatency.length) : 0,
                    memoryUsage: memoryStats.usage,
                    vocabularySize: this.nlp.vocabulary.size,
                    isLearning: this.isLearning,
                    totalMemories: memoryStats.shortTerm + memoryStats.longTerm
                };
            }

            toggleLearning() {
                this.isLearning = !this.isLearning;
                return this.isLearning;
            }

            save() {
                return JSON.stringify({
                    conversationHistory: this.conversationHistory,
                    memory: {
                        shortTerm: this.memory.shortTerm,
                        longTerm: this.memory.longTerm
                    },
                    stats: this.getStats(),
                    timestamp: Date.now()
                });
            }

            load(data) {
                try {
                    const parsed = JSON.parse(data);
                    this.conversationHistory = parsed.conversationHistory || [];
                    if (parsed.memory) {
                        this.memory.shortTerm = parsed.memory.shortTerm || [];
                        this.memory.longTerm = parsed.memory.longTerm || [];
                    }
                    return true;
                } catch (e) {
                    console.error('Load failed:', e);
                    return false;
                }
            }
        }

        // Chat Interface
        class ChatInterface {
            constructor(aiAgent) {
                this.ai = aiAgent;
                this.isTyping = false;
                this.messagesContainer = document.getElementById('messages');
                this.messageInput = document.getElementById('message-input');
                this.sendButton = document.getElementById('send-button');
                
                this.setupEventListeners();
                this.showWelcome();
                this.updateStats();
                
                // Auto-update stats
                setInterval(() => this.updateStats(), 5000);
            }

            setupEventListeners() {
                this.messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.sendMessage();
                    }
                });

                this.sendButton.addEventListener('click', () => this.sendMessage());

                // Auto-resize textarea
                this.messageInput.addEventListener('input', () => {
                    this.messageInput.style.height = 'auto';
                    this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 120) + 'px';
                });
            }

            showWelcome() {
                this.messagesContainer.innerHTML = '';
                this.addMessage(
                    `üéâ Ch√†o m·ª´ng ƒë·∫øn v·ªõi Self-Made AI Agent!<br><br>
                    ‚ú® T√¥i l√† m·ªôt AI assistant ƒë∆∞·ª£c t·∫°o ho√†n to√†n t·ª´ ƒë·∫ßu, kh√¥ng s·ª≠ d·ª•ng API ngo√†i<br>
                    üß† T√¥i c√≥ neural network, NLP engine v√† memory system ri√™ng<br>
                    üìö T√¥i c√≥ th·ªÉ h·ªçc h·ªèi t·ª´ cu·ªôc tr√≤ chuy·ªán v√† c·∫£i thi·ªán theo th·ªùi gian<br><br>
                    H√£y th·ª≠ h·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨!`,
                    false
                );
                
                // Enable send button
                this.sendButton.disabled = false;
            }

            async sendMessage() {
                const message = this.messageInput.value.trim();
                if (!message || this.isTyping) return;

                // Add user message
                this.addMessage(message, true);
                this.messageInput.value = '';
                this.messageInput.style.height = 'auto';

                // Show typing
                this.showTyping();

                try {
                    // Get AI response
                    const response = await this.ai.processMessage(message);
                    
                    // Hide typing and add response
                    this.hideTyping();
                    this.addMessage(response.content, false, response);
                    
                    // Update stats
                    this.updateStats();

                } catch (error) {
                    this.hideTyping();
                    this.addMessage('Xin l·ªói, t√¥i g·∫∑p s·ª± c·ªë. H√£y th·ª≠ l·∫°i!', false);
                }
            }

            addMessage(content, isUser, metadata = {}) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'ai'}`;
                
                const avatar = document.createElement('div');
                avatar.className = 'message-avatar';
                avatar.textContent = isUser ? 'üë§' : 'ü§ñ';
                
                const contentDiv = document.createElement('div');
                contentDiv.className = 'message-content';
                contentDiv.innerHTML = content;
                
                const timeDiv = document.createElement('div');
                timeDiv.className = 'message-time';
                timeDiv.textContent = new Date().toLocaleTimeString();
                
                messageDiv.appendChild(avatar);
                messageDiv.appendChild(contentDiv);
                
                if (!isUser && metadata.confidence) {
                    const metaDiv = document.createElement('div');
                    metaDiv.className = 'metadata';
                    metaDiv.innerHTML = `Confidence: ${(metadata.confidence * 100).toFixed(0)}% | ${metadata.processingTime}ms | Intent: ${metadata.intent}`;
                    contentDiv.appendChild(metaDiv);
                }
                
                contentDiv.appendChild(timeDiv);
                this.messagesContainer.appendChild(messageDiv);
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            showTyping() {
                this.isTyping = true;
                const typingDiv = document.createElement('div');
                typingDiv.className = 'message ai typing-indicator';
                typingDiv.id = 'typing-indicator';
                
                typingDiv.innerHTML = `
                    <div class="message-avatar">ü§ñ</div>
                    <div class="message-content">
                        <div class="typing-dots">
                            <span></span><span></span><span></span>
                        </div>
                        ƒêang suy nghƒ©...
                    </div>
                `;
                
                this.messagesContainer.appendChild(typingDiv);
                this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
            }

            hideTyping() {
                this.isTyping = false;
                const typingIndicator = document.getElementById('typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
            }

            updateStats() {
                const stats = this.ai.getStats();
                
                document.getElementById('stat-conversations').textContent = stats.conversations;
                document.getElementById('stat-response-time').textContent = stats.averageResponseTime + 'ms';
                document.getElementById('stat-memory').textContent = stats.memoryUsage + '%';
                document.getElementById('stat-vocabulary').textContent = stats.vocabularySize;
                document.getElementById('stat-learning').textContent = stats.isLearning ? 'ON' : 'OFF';
                
                // Update insights
                const insights = document.getElementById('insights');
                insights.innerHTML = `
                    <div style="font-size: 0.8rem; color: #8892b0;">
                        üí≠ Total memories: ${stats.totalMemories}<br>
                        üéØ Learning: ${stats.isLearning ? 'Active' : 'Inactive'}<br>
                        ‚ö° Avg response: ${stats.averageResponseTime}ms
                    </div>
                `;
            }
        }

        // Global Variables
        let aiAgent;
        let chatInterface;

        // Control Functions
        function toggleLearning() {
            const isLearning = aiAgent.toggleLearning();
            alert(`Learning ${isLearning ? 'enabled' : 'disabled'}`);
            chatInterface.updateStats();
        }

        function trainAI() {
            alert('Neural network training simulated! (In full implementation, this would train on conversation data)');
        }

        function saveAgent() {
            const data = aiAgent.save();
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ai-agent-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadAgent() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (aiAgent.load(e.target.result)) {
                            alert('AI Agent loaded successfully!');
                            chatInterface.updateStats();
                        } else {
                            alert('Failed to load AI Agent data.');
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        function exportChat() {
            const conversations = aiAgent.conversationHistory;
            const text = conversations.map(conv => 
                `[${new Date(conv.timestamp).toLocaleString()}]\nUser: ${conv.user}\nAI: ${conv.ai}\n\n`
            ).join('');
            
            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chat-history-${new Date().toISOString().slice(0, 10)}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetAgent() {
            if (confirm('Are you sure you want to reset the AI Agent? All conversation history will be lost.')) {
                aiAgent = new AIAgent();
                chatInterface = new ChatInterface(aiAgent);
                alert('AI Agent has been reset!');
            }
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Initializing Self-Made AI Agent...');
            
            aiAgent = new AIAgent();
            chatInterface = new ChatInterface(aiAgent);
            
            console.log('‚úÖ AI Agent ready!');
            
            // Update status
            document.getElementById('status-text').textContent = 'Ready';
        });
    </script>
</body>
</html>